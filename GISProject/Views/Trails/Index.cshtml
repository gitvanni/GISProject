<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>@ViewData["Title"]</title>
    <script src="https://cdn.jsdelivr.net/npm/ol@7.3.0/dist/ol.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@7.3.0/ol.css" />
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: sans-serif;
        }

        #map {
            position: absolute;
            inset: 0;
        }

        .controls-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
        }

        .filters-panel {
            position: absolute;
            top: 10px;
            left: 220px;
            z-index: 1000;
        }

            .controls-panel details, .filters-panel details {
                background: rgba(255,255,255,0.9);
                border-radius: 4px;
                margin-bottom: 6px;
                padding: 6px 8px;
                width: 200px;
                box-shadow: 0 1px 4px rgba(0,0,0,0.2);
            }

            .controls-panel summary, .filters-panel summary {
                font-weight: bold;
                cursor: pointer;
                margin: -6px -8px 6px;
                padding: 6px 8px;
                list-style: none;
            }

            .controls-panel button, .controls-panel input,
            .filters-panel button, .filters-panel input {
                width: 100%;
                margin: 4px 0;
                padding: 6px;
                font-size: 13px;
                box-sizing: border-box;
            }

        #drawNotification {
            display: none;
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            z-index: 1000;
        }

        #legend {
            background: rgba(255,255,255,0.9);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            margin-top: 10px;
        }

            #legend ul {
                margin: 4px 0 0 16px;
                padding: 0;
            }

        #infoSidebar {
            position: absolute;
            top: 0;
            right: 0;
            width: 280px;
            height: 100%;
            background: rgba(255,255,255,0.95);
            border-left: 1px solid #ccc;
            padding: 16px;
            display: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <div class="controls-panel">
        <details>
            <summary>Operazioni</summary>
            <button onclick="enableDrawing()">Disegna Trail</button>
            <button id="cancelButton" onclick="cancelDrawing()">Annulla Disegno</button>
            <button onclick="enableEditMode()">Modifica Trail</button>
            <button onclick="enableTrailSpatialFilter()">Filtro Spaziale</button>
            <button onclick="loadOnlyPolygonTrails()">Solo percorsi chiusi (Poligoni)</button>
            <button onclick="loadIntersectingTrails()">Solo interesezioni tra trail</button>

        </details>
        <details>
            <summary>Filtri Difficoltà</summary>
            <button onclick="loadTrailsByDifficulty('All')">Tutti</button>
            <button onclick="loadTrailsByDifficulty('Easy')">Easy</button>
            <button onclick="loadTrailsByDifficulty('Moderate')">Moderate</button>
            <button onclick="loadTrailsByDifficulty('Hard')">Hard</button>
        </details>
    </div>

    <div class="filters-panel">
        <details>
            <summary>Filtri Avanzati</summary>

            <input id="minArea" placeholder="Area ≥ (m²)" type="number" />
            <button onclick="loadTrailsByArea()">Filtra Area</button>

            <input id="minLength" placeholder="Lunghezza ≥ (m)" type="number" />
            <button onclick="loadTrailsByLength()">Filtra Lunghezza</button>

            <input id="nearestCount" placeholder="N vicini" type="number" />
            <button onclick="enableNearestMode()">Seleziona Trail per Vicini</button>

            <input id="attrField" placeholder="Campo (es. name)" type="text" />
            <input id="attrValue" placeholder="Valore" type="text" />
            <button onclick="loadTrailsByAttribute()">Filtra Attributo</button>

            <div id="legend">
                <strong>Legenda:</strong>
                <ul>
                    <li>🖱️ Sinistro: aggiungi punto</li>
                    <li>🖱️ Destro (1° click): chiudi segmento</li>
                    <li>🖱️ Destro (2° click): salva trail</li>
                    <li>⎋ ESC: annulla</li>
                </ul>
            </div>
        </details>
    </div>

    <div id="drawNotification">✏️ Disegna trail attivo</div>
    <div id="infoSidebar">
        <h3>Trail Info</h3>
        <p><strong>Nome:</strong> <span id="trailName"></span></p>
        <p><strong>Difficoltà:</strong> <span id="trailDifficulty"></span></p>
        <input type="hidden" id="trailId" />
        <button onclick="deleteTrail()" style="background:#c00;color:#fff;">Elimina</button>
        <button onclick="closeSidebar()">Chiudi</button>
    </div>

    <script>

        let activeTrailFilter = null;

        function closeSidebar() {
          document.getElementById('infoSidebar').style.display = 'none';
        }

        // fonte e layer vettoriale
        const vectorSource = new ol.source.Vector();
        const vectorLayer = new ol.layer.Vector({
          source: vectorSource,
          style: feature => {
            const color  = getColor(feature.get('difficulty'));
            const stroke = new ol.style.Stroke({ color, width: 3 });
            let fill = null;
            if (feature.getGeometry().getType() === 'Polygon') {
              // semi-trasparente ma cliccabile
              fill = new ol.style.Fill({
                color: color === 'red'
                  ? 'rgba(255,0,0,0.2)'
                  : 'rgba(0,128,0,0.2)'
              });
            }
            return new ol.style.Style({ stroke, fill });
          }
        });

        // mappa
        const map = new ol.Map({
          target: 'map',
          layers: [
            new ol.layer.Tile({ source: new ol.source.OSM() }),
            vectorLayer
          ],
          view: new ol.View({
            center: ol.proj.fromLonLat([12.5, 42.5]),
            zoom: 6
          })
        });

        // GeoJSON reader (legge FeatureCollection → ol.Feature[])
        const geojsonFormat = new ol.format.GeoJSON({
          featureProjection: 'EPSG:3857'
        });

        // helper per fetch + rendering
        async function fetchAndRender(url, fetchOptions = {}) {
          const res = await fetch(url, fetchOptions);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const geojson = await res.json();
          vectorSource.clear();
          const features = geojsonFormat.readFeatures(geojson);
          vectorSource.addFeatures(features);
        }

        // mappa enum → colore
        function getColor(difficulty) {
          const d = typeof difficulty === 'string'
            ? difficulty.toLowerCase()
            : difficulty;
          // easy e moderate → verde, hard → rosso
          if (d === 'hard' || d === 3)   return 'red';
          if (d === 'moderate' || d === 2) return 'yellow';
          if (d === 'easy' || d === 1) return 'green';
          return 'blue';
        }


        // carica tutte le trail nell’estensione corrente
        async function loadTrailsFromMapExtent() {
          if (activeTrailFilter) return;
          const extent = map.getView().calculateExtent(map.getSize());
          const bl = ol.proj.toLonLat(ol.extent.getBottomLeft(extent));
          const tr = ol.proj.toLonLat(ol.extent.getTopRight(extent));

          const url = `/api/trailsapi`
                    + `?minLon=${bl[0]}&minLat=${bl[1]}`
                    + `&maxLon=${tr[0]}&maxLat=${tr[1]}`;

          await fetchAndRender(url);
        }

        // filtra per difficoltà
        async function loadTrailsByDifficulty(level) {
          activeTrailFilter = level === 'All' ? null : level;

          const extent = map.getView().calculateExtent(map.getSize());
          const bl = ol.proj.toLonLat(ol.extent.getBottomLeft(extent));
          const tr = ol.proj.toLonLat(ol.extent.getTopRight(extent));

          const base = `/api/trailsapi`;
          const url  = level === 'All'
            ? `${base}?minLon=${bl[0]}&minLat=${bl[1]}&maxLon=${tr[0]}&maxLat=${tr[1]}`
            : `${base}/bydifficulty?level=${level}`
              + `&minLon=${bl[0]}&minLat=${bl[1]}&maxLon=${tr[0]}&maxLat=${tr[1]}`;

          await fetchAndRender(url);
        }

        // ricarica al termine del movimento
        window.addEventListener('DOMContentLoaded', loadTrailsFromMapExtent);
        map.on('moveend', loadTrailsFromMapExtent);

        // writer per estrarre GeoJSON in EPSG:4326 dal client (usato da spatialFilter)
        const geojsonWriter = new ol.format.GeoJSON({
          featureProjection: 'EPSG:3857',
          dataProjection:    'EPSG:4326'
        });

        // --- FILTRO SPAZIALE (POST) ---
        async function enableTrailSpatialFilter() {
          // disegna un poligono per filtrare
          const draw = new ol.interaction.Draw({
            source: new ol.source.Vector(),
            type:   'Polygon'
          });
          map.addInteraction(draw);

          draw.on('drawend', async evt => {
            map.removeInteraction(draw);
            const geomObj = geojsonWriter.writeGeometryObject(evt.feature.getGeometry());

            await fetchAndRender('/api/trailsapi/spatialfilter', {
                method:  'POST',
                headers: { 'Content-Type': 'application/json' },
                body:    JSON.stringify({ geometry: geomObj })
              });
          });
        }

        async function loadOnlyPolygonTrails() {
          activeTrailFilter = 'PolygonOnly';
          await loadTrailsFromMapExtent();             
          const polys = vectorSource.getFeatures()
            .filter(f => f.getGeometry().getType() === 'Polygon');
          vectorSource.clear();
          vectorSource.addFeatures(polys);
        }

        // --- FILTRO GENERICO PER ATTRIBUTO ---
        async function loadTrailsByAttribute() {
          const field = document.getElementById('attrField').value.trim();
          const value = document.getElementById('attrValue').value.trim();
          if (!field || !value) return alert('Inserisci campo e valore');

          const extent = map.getView().calculateExtent(map.getSize());
          const bl = ol.proj.toLonLat(ol.extent.getBottomLeft(extent));
          const tr = ol.proj.toLonLat(ol.extent.getTopRight(extent));

          const url = `/api/trailsapi/filter`
            + `?filterField=${encodeURIComponent(field)}`
            + `&filterValue=${encodeURIComponent(value)}`
            + `&minLon=${bl[0]}&minLat=${bl[1]}`
            + `&maxLon=${tr[0]}&maxLat=${tr[1]}`;

          await fetchAndRender(url);
        }

        // --- FILTRO PER AREA ---
        async function loadTrailsByArea() {
          const m2 = parseFloat(document.getElementById('minArea').value);
          if (isNaN(m2)) return alert('Area non valida');

          // conversione m²→gradi² (approx)
          const METERS_PER_DEG = 111_320;
          const minAreaDeg2 = m2 / (METERS_PER_DEG * METERS_PER_DEG);

          await fetchAndRender(
            `/api/trailsapi/byarea?minArea=${minAreaDeg2}`
          );
        }

        // --- FILTRO PER LUNGHEZZA ---
        async function loadTrailsByLength() {
          const m = parseFloat(document.getElementById('minLength').value);
          if (isNaN(m)) return alert('Lunghezza non valida');

          // extent corrente
          const ext = map.getView().calculateExtent(map.getSize());
          const bl  = ol.proj.toLonLat(ol.extent.getBottomLeft(ext));
          const tr  = ol.proj.toLonLat(ol.extent.getTopRight(ext));

          // conversione m→gradi (approx)
          const deg = m / 111_320;

          const url = `/api/trailsapi/bylength`
            + `?minLength=${deg}`
            + `&minLon=${bl[0]}&minLat=${bl[1]}`
            + `&maxLon=${tr[0]}&maxLat=${tr[1]}`;

          await fetchAndRender(url);
        }

        // --- TROVA N VICINI ---
        function enableNearestMode() {
          const n = parseInt(document.getElementById('nearestCount').value);
          if (isNaN(n) || n < 1) return alert('N non valido');

          document.getElementById('drawNotification').textContent = '📍 Clicca su un trail';
          document.getElementById('drawNotification').style.display  = 'block';
          map.getTargetElement().style.cursor = 'pointer';

          map.once('singleclick', async evt => {
            document.getElementById('drawNotification').style.display = 'none';
            map.getTargetElement().style.cursor = '';

            const feat = map.forEachFeatureAtPixel(evt.pixel, f=>f);
            if (!feat) return alert('Seleziona una trail valida');

            // centro del feature
            const geom = feat.getGeometry();
            const coord = geom.getType() === 'Polygon'
              ? ol.extent.getCenter(geom.getExtent())
              : geom.getCoordinateAt(0.5);
            const [lon, lat] = ol.proj.toLonLat(coord);

            const url = `/api/trailsapi/nearest?lon=${lon}&lat=${lat}&n=${n}`;
            await fetchAndRender(url);
          });
        }

        // --- SELEZIONE & DELETE ---
        let selectedFeature = null;

        // click per selezione feature
        map.on('singleclick', evt => {
          if (drawActive) return;
          const f = map.forEachFeatureAtPixel(evt.pixel, feat => feat);
          if (f) {
            selectedFeature = f;
            document.getElementById('trailName').textContent       = f.get('name');
            document.getElementById('trailDifficulty').textContent = f.get('difficulty');
            document.getElementById('trailId').value               = f.get('id');
            document.getElementById('infoSidebar').style.display   = 'block';
          } else {
            selectedFeature = null;
            closeSidebar();
          }
        });

        async function deleteTrail() {
          const id = document.getElementById('trailId').value;
          if (!id || !confirm("Confermi l'eliminazione?")) return;
          const res = await fetch(`/api/trailsapi/${id}`, { method: 'DELETE' });
          if (res.ok) {
            closeSidebar();
            loadTrailsFromMapExtent();
          } else {
            alert("Errore durante l'eliminazione.");
          }
        }

        // --- DRAWING (LineString / MultiLineString / Polygon) ---
        let drawActive = false;
        let drawSegments = [[]];
        let ghostFeature = null;
        let newTrailName, newTrailDifficulty;

        function enableDrawing() {
          const name = prompt("Nome del trail:");
          if (!name) return;
          const diff = prompt("Difficoltà (Easy, Moderate, Hard):", "Moderate");
          if (!diff) return;

          drawActive = true;
          drawSegments = [[]];
          newTrailName = name;
          newTrailDifficulty = diff;

          document.getElementById('drawNotification').style.display = 'block';
          map.getTargetElement().style.cursor = 'crosshair';
        }

        function cancelDrawing() {
          drawActive = false;
          drawSegments = [[]];
          if (ghostFeature) {
            vectorSource.removeFeature(ghostFeature);
            ghostFeature = null;
          }
          document.getElementById('drawNotification').style.display = 'none';
          map.getTargetElement().style.cursor = '';
        }

        // click sinistro = aggiungi punto
        map.on('click', evt => {
          if (!drawActive) return;
          const coord = ol.proj.toLonLat(evt.coordinate);
          const seg   = drawSegments[drawSegments.length - 1];
          seg.push(coord);
        });

        // pointermove = anteprima tratto (ghost)
        map.on('pointermove', evt => {
          if (!drawActive) return;
          const allLines = [];
          // segmenti già chiusi
          drawSegments.slice(0, -1).forEach(seg => {
            if (seg.length > 1) allLines.push(seg.map(c => ol.proj.fromLonLat(c)));
          });
          // segmento corrente + mouse
          const curr = drawSegments[drawSegments.length - 1];
          if (curr.length > 0) {
            const preview = [...curr, ol.proj.toLonLat(evt.coordinate)];
            allLines.push(preview.map(c => ol.proj.fromLonLat(c)));
          }
          const multi = new ol.geom.MultiLineString(allLines);
          if (!ghostFeature) {
            ghostFeature = new ol.Feature({ geometry: multi });
            ghostFeature.setStyle(new ol.style.Style({
              stroke: new ol.style.Stroke({ color: 'blue', width: 2, lineDash: [4,4] })
            }));
            vectorSource.addFeature(ghostFeature);
          } else {
            ghostFeature.setGeometry(multi);
          }
        });

        // right-click: chiudi segmento o finalizza
        map.getViewport().addEventListener('contextmenu', evt => {
          if (!drawActive) return;
          evt.preventDefault();
          const seg = drawSegments[drawSegments.length - 1];
          if (seg.length === 0) {
            finalizeDrawing();
          } else {
            drawSegments.push([]);
          }
        });

        async function finalizeDrawing() {
          drawActive = false;
          document.getElementById('drawNotification').style.display = 'none';
          map.getTargetElement().style.cursor = '';

          const valid = drawSegments.filter(s => s.length > 1);
          if (valid.length === 0) {
            alert("Nessuna linea valida disegnata.");
            return;
          }

          let geometry, trailType;
          if (valid.length === 1 && valid[0].length >= 4) {
            // POLYGON
            const ring = valid[0];
            if (!(ring[0][0]===ring[ring.length-1][0] && ring[0][1]===ring[ring.length-1][1]))
              ring.push(ring[0]);
            geometry  = { type: "Polygon", coordinates: [ring] };
            trailType = "Polygon";
          }
          else if (valid.length > 1) {
            // MULTILINE
            geometry  = { type: "MultiLineString", coordinates: valid };
            trailType = "MultiLine";
          }
          else {
            // LINESTRING
            geometry  = { type: "LineString", coordinates: valid[0] };
            trailType = "Line";
          }

          const body = {
            name:       newTrailName,
            difficulty: newTrailDifficulty,
            trailType,
            geometry
          };

          try {
            const res = await fetch('/api/trailsapi', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(body)
            });
            if (res.ok) loadTrailsFromMapExtent();
            else alert("Errore nel salvataggio.");
          } catch {
            alert("Errore di rete durante il salvataggio.");
          }

          drawSegments = [[]];
          if (ghostFeature) {
            vectorSource.removeFeature(ghostFeature);
            ghostFeature = null;
          }
        }

        // ESC e ENTER per annullare/finalizzare il disegno
        document.addEventListener('keydown', evt => {
          if (evt.key === 'Escape' && drawActive) cancelDrawing();
        });


        // --- EDIT MODE ---
        let modifyInteraction = null;

        function enableEditMode() {
          if (!selectedFeature) {
            alert("Seleziona prima un trail.");
            return;
          }
          if (modifyInteraction) map.removeInteraction(modifyInteraction);
          modifyInteraction = new ol.interaction.Modify({
            features: new ol.Collection([selectedFeature])
          });
          map.addInteraction(modifyInteraction);
          document.getElementById('drawNotification').textContent = '✏️ Modifica attiva, ENTER per salva, ESC per annulla';
          document.getElementById('drawNotification').style.display = 'block';
        }

        function cancelEditing() {
          if (modifyInteraction) {
            map.removeInteraction(modifyInteraction);
            modifyInteraction = null;
          }
          document.getElementById('drawNotification').style.display = 'none';
          loadTrailsFromMapExtent();
        }

        async function finalizeEdit() {
          if (!selectedFeature) return;
          const id         = document.getElementById('trailId').value;
          const name       = document.getElementById('trailName').textContent;
          const difficulty = document.getElementById('trailDifficulty').textContent;
          const geom       = selectedFeature.getGeometry();
          let geometry, trailType;

          const type = geom.getType();
          if (type === 'LineString') {
            geometry  = { type, coordinates: geom.getCoordinates().map(c=>ol.proj.toLonLat(c)) };
            trailType = 'Line';
          } else if (type === 'MultiLineString') {
            geometry  = { type, coordinates: geom.getLineStrings().map(ls=>ls.getCoordinates().map(c=>ol.proj.toLonLat(c))) };
            trailType = 'MultiLine';
          } else if (type === 'Polygon') {
            const ring = geom.getCoordinates()[0].map(c=>ol.proj.toLonLat(c));
            geometry  = { type, coordinates: [ring] };
            trailType = 'Polygon';
          } else {
            alert("Geometria non supportata per l'aggiornamento.");
            return;
          }

          const body = { name, difficulty, trailType, geometry };

          const res = await fetch(`/api/trailsapi/${id}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
          });

          document.getElementById('drawNotification').style.display = 'none';
          map.removeInteraction(modifyInteraction);
          modifyInteraction = null;

          if (res.ok) {
            loadTrailsFromMapExtent();
            closeSidebar();
            alert("Modifiche salvate.");
          } else {
            alert("Errore durante il salvataggio delle modifiche.");
          }
        }

        document.addEventListener('keydown', evt => {
          if (evt.key === 'Enter' && modifyInteraction) finalizeEdit();
          if (evt.key === 'Escape' && modifyInteraction) cancelEditing();
        });

        async function loadIntersectingTrails() {
          // chiude eventuali altri filtri attivi
          activeTrailFilter = 'Intersections';
          // richiesta al nuovo endpoint
          await fetchAndRender('/api/trailsapi/intersections');
        }
    </script>

</body>
</html>

